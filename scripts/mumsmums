#!/usr/bin/env bash

set -euo pipefail

GIT_DIR=$(git rev-parse --show-toplevel)
COMMAND="${1:-}"
shift || true

show_usage() {
  1>&2 cat <<EOM
CLI to manage the mumsmums application.

USAGE:
    mumsmums <COMMAND> [OPTIONS]

COMMANDS:
    build [--docker]        - Build all sources (server + client) or build Docker images
    test                    - Run all tests
    start [--docker]        - Start the app locally or run it in docker
    stop [--docker]         - Stop the app locally or the docker containers running it
EOM
    exit 1
}

build_server() {
  echo "### Building server..." >&2
  cd "$GIT_DIR"
  bazel build //...
  bazel build //src/server/jvmMain/kotlin/app/mumsmums:mumsmums_deploy.jar
  echo "### Server build complete." >&2
}

build_client() {
    echo "### Building client, start a local server for SSR..." >&2

    start_local_server

    echo '### Building client sources...'
    cd "$GIT_DIR/src/client" || exit 1

    npm ci
    npm run lint
    npm run lint:tsc

    # Build with localhost backend for build-time SSR
    NEXT_PUBLIC_USE_LOCAL_BACKEND=true npm run build --if-present

    echo "### Client build complete, stopping local server" >&2

    stop_local
}

build_all() {
    build_server
    build_client
}

test_all() {
    echo "### Running all server tests..." >&2
    (cd "$GIT_DIR" && bazel test //...)

    echo "### Running all frontend tests..." >&2
    (cd "$GIT_DIR/src/client" && npm run test)
}

wait_for_server() {
    local timeout_seconds="${1:-30}"
    local log_file="${2:-}"

    echo "### Waiting for local server to be ready (timeout: ${timeout_seconds}s)..." >&2

    for i in $(seq 1 "$timeout_seconds"); do
        if curl -s http://localhost:8080/graphql > /dev/null 2>&1; then
            return 0
        fi

        if [ "$i" -eq "$timeout_seconds" ]; then
            echo "### Server failed to start after ${timeout_seconds} seconds" >&2
            if [ -n "$log_file" ] && [ -f "$log_file" ]; then
                echo "### Server logs:" >&2
                cat "$log_file" >&2
            fi
            return 1
        fi

        sleep 1
    done
}

start_local_server() {
    local log_file="${1:-/tmp/mumsmums-server.log}"
    local timeout_seconds="${2:-30}"

    echo "### Starting local server..." >&2

    # Start server in background
    cd "$GIT_DIR"
    bazel run //src/server/jvmMain/kotlin/app/mumsmums > "$log_file" 2>&1 &
    local server_pid=$!

    # Wait for server to be ready
    if wait_for_server "$timeout_seconds" "$log_file"; then
        echo "### Server with pid: $server_pid started at http://localhost:8080" >&2
    else
        kill "$server_pid" 2>/dev/null || true
        exit 1
    fi
}

start_local() {
    # Start server
    start_local_server

    # Guard to prevent duplicate cleanup
    _cleanup_done=0
    cleanup() {
        if [ $_cleanup_done -eq 0 ]; then
            _cleanup_done=1
            stop_local
        fi
    }

    # Ensure server stops when client exits or on Ctrl+C
    trap cleanup EXIT INT TERM

    # Start client in foreground
    echo "### Starting client at http://localhost:3000..." >&2
    cd "$GIT_DIR/src/client"
    npm run dev
}

build_docker() {
    echo "### Building Docker images with multi-stage builds..." >&2
    cd "$GIT_DIR"

    # Get the directory name to determine the image prefix
    local dir_name=$(basename "$GIT_DIR")

    # Clean up any leftover build containers from previous attempts
    docker rm -f mumsmums-build-backend-temp 2>/dev/null || true
    rm -rf /tmp/mumsmums-build-persist

    # Step 1: Build backend image
    echo "### Building backend image..." >&2
    docker compose build backend

    # Step 2: Start backend temporarily using docker run to avoid port conflicts
    echo "### Starting backend temporarily for frontend SSR build..." >&2

    # Create a temporary persistent data directory for the build backend
    mkdir -p /tmp/mumsmums-build-persist

    # Start backend on port 8081 to avoid conflicts
    # Use the image name that docker compose created (dir_name-backend)
    docker run -d \
        --name mumsmums-build-backend-temp \
        -p 8081:8080 \
        -v /tmp/mumsmums-build-persist:/app/sqlite \
        -e JWT_SECRET=build-temp-secret \
        -e SECURE_COOKIES=false \
        ${dir_name}-backend

    # Wait for backend to be healthy
    echo "### Waiting for backend to be healthy..." >&2
    local timeout=60
    local elapsed=0
    until curl -f http://localhost:8081/health > /dev/null 2>&1; do
        if [ $elapsed -ge $timeout ]; then
            echo "### Backend failed to start within ${timeout}s" >&2
            docker logs mumsmums-build-backend-temp >&2
            docker rm -f mumsmums-build-backend-temp
            rm -rf /tmp/mumsmums-build-persist
            exit 1
        fi
        sleep 1
        elapsed=$((elapsed + 1))
    done
    echo "### Backend is healthy" >&2

    # Step 3: Build frontend image (connects to backend via host.docker.internal during build)
    echo "### Building frontend image with SSR..." >&2
    docker compose build --build-arg NEXT_PUBLIC_BACKEND_URL=http://host.docker.internal:8081 frontend

    # Step 4: Stop and remove temporary backend
    echo "### Stopping temporary backend..." >&2
    docker rm -f mumsmums-build-backend-temp
    rm -rf /tmp/mumsmums-build-persist

    echo "### Docker images built successfully" >&2
}

start_docker() {
    # Create persistent data directories if they don't exist
    mkdir -p ~/mumsmums-persist/images/recipes

    # Build Docker images
    build_docker

    # Start all services
    echo "### Starting containers with docker compose..." >&2
    cd "$GIT_DIR"
    docker compose up -d

    echo "### Done! Application is running:" >&2
    echo "  - Backend: http://localhost:8080" >&2
    echo "  - Frontend: http://localhost:3000" >&2
    echo "  - Caddy (reverse proxy): http://localhost:80" >&2
    echo "" >&2
    echo "To view logs: docker compose logs -f" >&2
    echo "To stop: ./scripts/mumsmums stop --docker" >&2
}

stop_local() {
    echo "### Stopping server..." >&2

    local found_processes=0

    # Find and kill any bazel server processes
    local bazel_pids=$(pgrep -f "bazel-out.*mumsmums" 2>/dev/null || true)
    if [ -n "$bazel_pids" ]; then
        echo "### Killing bazel processes: $bazel_pids" >&2
        echo "$bazel_pids" | xargs kill 2>/dev/null || true
        found_processes=1
    fi

    # Kill anything on port 8080
    local port_pids=$(lsof -ti:8080 2>/dev/null || true)
    if [ -n "$port_pids" ]; then
        echo "### Killing processes on port 8080: $port_pids" >&2
        echo "$port_pids" | xargs kill -9 2>/dev/null || true
        found_processes=1
    fi

    if [ $found_processes -eq 0 ]; then
        echo "### Server is not running, nothing to stop" >&2
    else
        echo "### Server stopped" >&2
    fi
}

stop_docker() {
    echo "### Stopping docker containers..." >&2
    cd "$GIT_DIR"
    docker compose down
    echo "### Docker containers stopped" >&2
}

case "$COMMAND" in
    build)
        if [ "${1:-}" = "--docker" ]; then
            build_docker
        else
            build_all
        fi
        ;;

    test)
        test_all
        ;;

    deploy)
        deploy "$1" "$2"
        ;;

    start)
        if [ "${1:-}" = "--docker" ]; then
            start_docker
        else
            start_local
        fi
        ;;

    stop)
        if [ "${1:-}" = "--docker" ]; then
            stop_docker
        else
            stop_local
        fi
        ;;

    *)
        show_usage
        ;;
esac
