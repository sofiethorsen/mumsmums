#!/usr/bin/env bash

set -euo pipefail

GIT_DIR=$(git rev-parse --show-toplevel)
COMMAND="${1:-}"
shift || true

show_usage() {
  1>&2 cat <<EOM
CLI to manage the mumsmums application.

USAGE:
    mumsmums <COMMAND> [OPTIONS]

COMMANDS:
    build                   - Build all sources (server + client)
    test                    - Run all tests
    deploy <host> <port>    - Deploy the app to remote host (e.g., deploy user@xxxx.xxx.x.xxx 1234)
    start [--docker]        - Start the app locally or run it in docker
    stop [--docker]         - Stop the app locally or the docker containers running it
EOM
    exit 1
}

build_server() {
  echo "### Building server..." >&2
  cd "$GIT_DIR"
  bazel build //...
  bazel build //src/server/jvmMain/kotlin/app/mumsmums:mumsmums_deploy.jar
  echo "### Server build complete." >&2
}

build_client() {
    echo "### Building client, start a local server for SSR..." >&2

    start_local_server

    echo '### Building client sources...'
    cd "$GIT_DIR/src/client" || exit 1

    npm ci
    npm run lint
    npm run lint:tsc

    # Build with localhost backend for build-time SSR
    NEXT_PUBLIC_USE_LOCAL_BACKEND=true npm run build --if-present

    echo "### Client build complete, stopping local server" >&2

    stop_local
}

build_all() {
    build_server
    build_client
}

test_all() {
    echo "### Running all server tests..." >&2
    (cd "$GIT_DIR" && bazel test //...)

    echo "### Running all frontend tests..." >&2
    (cd "$GIT_DIR/src/client" && npm run test)
}

wait_for_server() {
    local timeout_seconds="${1:-30}"
    local log_file="${2:-}"

    echo "### Waiting for local server to be ready (timeout: ${timeout_seconds}s)..." >&2

    for i in $(seq 1 "$timeout_seconds"); do
        if curl -s http://localhost:8080/graphql > /dev/null 2>&1; then
            return 0
        fi

        if [ "$i" -eq "$timeout_seconds" ]; then
            echo "### Server failed to start after ${timeout_seconds} seconds" >&2
            if [ -n "$log_file" ] && [ -f "$log_file" ]; then
                echo "### Server logs:" >&2
                cat "$log_file" >&2
            fi
            return 1
        fi

        sleep 1
    done
}

start_local_server() {
    local log_file="${1:-/tmp/mumsmums-server.log}"
    local timeout_seconds="${2:-30}"

    echo "### Starting local server..." >&2

    # Start server in background
    cd "$GIT_DIR"
    bazel run //src/server/jvmMain/kotlin/app/mumsmums > "$log_file" 2>&1 &
    local server_pid=$!

    # Wait for server to be ready
    if wait_for_server "$timeout_seconds" "$log_file"; then
        echo "### Server with pid: $server_pid started at http://localhost:8080" >&2
    else
        kill "$server_pid" 2>/dev/null || true
        exit 1
    fi
}

start_local() {
    # Start server
    start_local_server

    # Guard to prevent duplicate cleanup
    _cleanup_done=0
    cleanup() {
        if [ $_cleanup_done -eq 0 ]; then
            _cleanup_done=1
            stop_local
        fi
    }

    # Ensure server stops when client exits or on Ctrl+C
    trap cleanup EXIT INT TERM

    # Start client in foreground
    echo "### Starting client at http://localhost:3000..." >&2
    cd "$GIT_DIR/src/client"
    npm run dev
}

start_docker() {
    # Clean up any existing containers and network
    echo "### Stopping any running containers before starting..." >&2
    docker-compose down 2>/dev/null || true

    # Build sources (this builds both backend and frontend with localhost:8080)
    echo "### Building sources..." >&2
    cd "$GIT_DIR"
    build_all

    # Create persistent data directory if it doesn't exist
    mkdir -p ~/mumsmums-persist

    # Build and start using docker-compose
    echo "### Building and starting containers with docker-compose..." >&2
    docker-compose up -d --build

    # Wait for backend to be ready
    if wait_for_server 30; then
        echo "### Done! Application is running:" >&2
        echo "  - Backend: http://localhost:8080" >&2
        echo "  - Frontend: http://localhost:3000" >&2
        echo "  - Caddy (reverse proxy): http://localhost:80" >&2
        echo "" >&2
        echo "To view logs: docker-compose logs -f" >&2
        echo "To stop: ./scripts/mumsmums stop --docker" >&2
    else
        echo "### Failed to start docker containers" >&2
        docker-compose logs backend >&2
        exit 1
    fi
}

stop_local() {
    echo "### Stopping server..." >&2

    local found_processes=0

    # Find and kill any bazel server processes
    local bazel_pids=$(pgrep -f "bazel-out.*mumsmums" 2>/dev/null || true)
    if [ -n "$bazel_pids" ]; then
        echo "### Killing bazel processes: $bazel_pids" >&2
        echo "$bazel_pids" | xargs kill 2>/dev/null || true
        found_processes=1
    fi

    # Kill anything on port 8080
    local port_pids=$(lsof -ti:8080 2>/dev/null || true)
    if [ -n "$port_pids" ]; then
        echo "### Killing processes on port 8080: $port_pids" >&2
        echo "$port_pids" | xargs kill -9 2>/dev/null || true
        found_processes=1
    fi

    if [ $found_processes -eq 0 ]; then
        echo "### Server is not running, nothing to stop" >&2
    else
        echo "### Server stopped" >&2
    fi
}

stop_docker() {
    echo "### Stopping docker containers..." >&2
    cd "$GIT_DIR"
    docker-compose down
    echo "### Docker containers stopped" >&2
}

deploy() {
  local deploy_host="$1"
  local ssh_port="$2"

  if [ -z "$deploy_host" ] || [ -z "$ssh_port" ]; then
    echo "Error: Missing required arguments" >&2
    echo "Usage: mumsmums deploy <user@host> <ssh-port>" >&2
    exit 1
  fi

  echo "### Deploying to $deploy_host (SSH port: $ssh_port)..." >&2

  # First, build all sources
  build_all

  # Copy JAR to stable build directory (bazel-bin symlink can be unstable after bazel processes are killed)
  cd "$GIT_DIR"
  rm -rf build
  mkdir -p build
  cp bazel-bin/src/server/jvmMain/kotlin/app/mumsmums/mumsmums_deploy.jar build/

  # Remove any existing build directory on the host machine
  ssh -p "$ssh_port" "$deploy_host" 'rm -rf ~/mumsmums'

  # Recreate directories
  ssh -p "$ssh_port" "$deploy_host" 'mkdir -p ~/mumsmums/build'
  ssh -p "$ssh_port" "$deploy_host" 'mkdir -p ~/mumsmums/src/client'
  ssh -p "$ssh_port" "$deploy_host" 'mkdir -p ~/mumsmums/src/server/jvmMain/resources'
  ssh -p "$ssh_port" "$deploy_host" 'mkdir -p ~/mumsmums/docker'

  # Create persistent data directory (separate from deployment directory)
  ssh -p "$ssh_port" "$deploy_host" 'mkdir -p ~/mumsmums-persist'

  # Transfer files
  scp -P "$ssh_port" build/mumsmums_deploy.jar "$deploy_host":~/mumsmums/build/
  scp -P "$ssh_port" src/server/jvmMain/resources/recipes.json "$deploy_host":~/mumsmums/src/server/jvmMain/resources/
  scp -P "$ssh_port" src/client/package*.json "$deploy_host":~/mumsmums/src/client/
  scp -P "$ssh_port" -r src/client/{.next,public} "$deploy_host":~/mumsmums/src/client/
  scp -P "$ssh_port" docker/{Caddyfile,mumsmums.Dockerfile,next.Dockerfile} "$deploy_host":~/mumsmums/docker/
  scp -P "$ssh_port" docker-compose.yml "$deploy_host":~/mumsmums/
  scp -P "$ssh_port" scripts/update-dns.sh "$deploy_host":~/mumsmums-persist/

  # Build the sources
  ssh -p "$ssh_port" "$deploy_host" 'cd ~/mumsmums && docker-compose build'

  # Stop the running app
  ssh -p "$ssh_port" "$deploy_host" 'cd ~/mumsmums && docker-compose down'

  # Start the new containers
  ssh -p "$ssh_port" "$deploy_host" 'cd ~/mumsmums && docker-compose up -d'

  echo "### Deployment to $deploy_host completed" >&2
}

case "$COMMAND" in
    build)
        build_all
        ;;

    test)
        test_all
        ;;

    deploy)
        deploy "$1" "$2"
        ;;

    start)
        if [ "${1:-}" = "--docker" ]; then
            start_docker
        else
            start_local
        fi
        ;;

    stop)
        if [ "${1:-}" = "--docker" ]; then
            stop_docker
        else
            stop_local
        fi
        ;;

    *)
        show_usage
        ;;
esac
